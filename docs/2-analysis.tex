\chapter{ Аналитический раздел }
Данный раздел посвящен анализу предметной области и задачи распознавания цилиндра и нахождения его геометрических размеров. Здесь также проводится обзор существующих методов и алгоритмов, позволяющих решить эту задачу.
Формально, алгоритм нахождения размеров состоит из нескольких шагов:
\begin{enumerate}
	\item Выделение границ цилиндра 
	\item Нахождение боковых граней цилиндра 
	\item На основе расстояния между найденными гранями и параметров камеры, вычислить размеры 
\end{enumerate}

Далее так же приводится анализ алгоритм трехмерного моделирования.

\section{ Анализ алгоритмов нахождения границ изображения }
Для решения данной задачи, было разработаны большое количество алгоритмов. Далее приведено описание наиболее популярных и используемых.
Также для ускорения работы алгоритмов, изображение желательно перевести в градации серого путем вычисления средневзвешенного количества красного, зеленого и синего цветов. в. Используется формула
\[Y = 0.3*R + 0.59*G + 0.11*B\]
эта величина также известна как свечение. Коэффициенты, используемые для расчета свечения, выбраны из соображений особенностей человеческого восприятия. Дело в том, что из базовых цветов, взятых в одинаковом количестве, человеческих глаз сперва выделяет зеленый, затем красный, а уже потом синий. Подразумевается, что когда зеленый и синий цвета излучаются монитором в одинаковом количестве, зеленый, тем не менее, выглядит ярче. Поэтому преобразование в градации серого цвета путем вычисления среднего арифметического цветовых компонент не отражает воспринимаемую человеком яркость оригинала. Для этого используется средневзвешенная величина.


\subsection{Оператор Собеля}
\label {sobel}
Оператор Собеля – дискретный дифференциальный оператор, вычисляющий приближенные значения производных разного порядка для функции яркости пикселей [1]. Наиболее распространенным примером практического использования является определение границ (ребер) объектов на изображении, т.е. точек резкого изменения яркости.

Данный оператор основан на свертке изображения с целочисленными фильтрами. В простейшем случае оператор построен на вычислении сверток исходного изображения с ядрами \(G_x\) и \(G_y\) , обеспечивающими вычисление первых производных по направлениям:


\begin{gather}
G_{x}=
\begin{bmatrix} 
-1 & 0 & 1 \\ 
-2 & 0 & 2 \\ 
-1 & 0 & 1
\end{bmatrix},
G_{y}=
\begin{bmatrix}
-1 & -2 & -1 \\ 
0 & 0 & 0 \\ 
1 & 2 & 1
\end{bmatrix}
\end{gather}

Данный оператор используется для приближенного вычисления градиента функции интенсивности пикселей. Применение оператора \(G_{x}\) позволяет определить приближенное значение первой частной производной изменения интенсивности в горизонтальном направлении, \(G_{y}\) – в вертикальном. На основании данной информации можно вычислить магнитуду градиента для пикселя с координатами (i,j) согласно формуле \(\mid G^{ij} \mid = \sqrt{(G_{x}^{ij})^2 + (G_{y}^{ij})^2}\). Также используя полученные данные, можно определить направление градиента как \(\theta^{ij} = arctan\left( \frac{G_{y}}{G_{x}}\right)\).

\subsection{Оператор Приютта}
Оператор Прюитта похож на оператор Собеля, но используются другие ядра:

\begin{gather}
G_{x}=
\begin{bmatrix} 
-1 & 0 & 1 \\ 
-1 & 0 & 1 \\ 
-1 & 0 & 1
\end{bmatrix},
G_{y}=
\begin{bmatrix}
-1 & -1 & -1 \\ 
0 & 0 & 0 \\ 
1 & 1 & 1
\end{bmatrix}
\end{gather}

\subsection{Оператор Робертса}
Оператор Робертса — один из ранних алгоритмов выделения границ, который вычисляет сумму квадратов разниц между диагонально смежными пикселами. Это может быть выполнено сверткой изображения с двумя ядрами:

\begin{gather}
G_{1}=
\begin{bmatrix} 
	1 & 0 \\ 
	0 & -1 \\ 
\end{bmatrix},
G_{2}=
\begin{bmatrix} 
	0 & 1 \\ 
	-1 & 0 \\ 
\end{bmatrix},
\end{gather}.

\subsection{Оператор Кэнни}
Данный алгоритм был разработан Джоном Кэнии в 1986 году. Его целью было разработать алгоритм алгоритм, который был бы оптимален по следующим критериям:
\begin{enumerate}
	\item Определение: вероятность определения точек реальных ребер должна быть максимальна, в то время как вероятность нахождения точек ложных ребер должна быть минимальна.
	\item Локализация: определенные ребра должны быть максимально близко к реальным ребрам.
	\item Количество ответов: одно реальное ребро, должно давать не более одного распознанного ребра.
\end{enumerate}
Алгоритм состоит из следующих пяти шагов.

\textbf{Сглаживание.} Неминуемо, что каждая фотография будет иметь некоторые шумы. Чтобы предотвратить ошибочное определение шумов как ребер, необходимо их удалить. Для этого к изображению применяется фильтр Гаусса. 
Ядро фильтра Гаусса с нормальным распределением \(\sigma = 1.4\) выглядит следующим образом:

\begin{gather} {B} ={\frac {1}{159}}{\begin{bmatrix}2&4&5&4&2\\4&9&12&9&4\\5&12&15&12&5\\4&9&12&9&4\\2&4&5&4&2\end{bmatrix}} \end{gather}

\textbf{Поиск градиентов.} 
Алгоритм Кэнни находит границы там, где интенсивность изображения меняется больше всего. Эти области находятся вычислением значений и направлений градиента. Градиент можно найти применением оператора Собеля, описанном в пункте \ref{sobel}.

\textbf{Подавление немаксимумов.} 
Целью данного шага является преобразование ``размытых'' границ на изображении градиентов в ``четкие''. Это может сделано сохранением всех локальных максимумов и подавлением всего остального. Алгоритм для каждого пикселя выглядит следующим образом:
\begin{itemize}
	\item Округление направления градиента \(\theta\) до ближайшего значения, кратного \(45^\circ\).
	\item Сравнение значения текущего пикселя, со значениями пекселей в положительном и отрицательном направлении градиента.
	\item Если значение текущего пикселя наибольшее, то сохраняем, иначе -- подавляем.
\end{itemize}

\textbf{Двойная пороговая фильтрация.} 
Пиксели, оставшиеся после предыдущего шага, вероятнее всего действительно будут ребрами, но некоторые из них могут быть получены из-за шумов или изменения цвета. Детектор границ Кэнни использует двойную пороговую фильтрацию. Пиксели, значения которых больше, чем верхняя граница, помечаются как ``сильные''. Пиксели, значения которых меньше, чем нижняя граница, подавляются, и пиксели, значения которых находятся между двумя границами помечаются как ``слабые''.

\textbf{Трассировка области неоднозначности.}
``Сильные'' пиксели, оставшиеся после предыдущего шага сразу добавляются в результирующие изображение. ``Слабые'' пиксели будут добавлены только в том случае, если они соприкасаются с ``сильными''.

\section{Анализ алгоритма нахождения прямых линий}
Наиболее распространенным алгоритмом поиска прямых является преобразование Хафа.
В простейшем случае преобразование Хафа является линейным преобразованием для обнаружения прямых. Прямая может быть задана уравнением \(y = mx + b\) и может быть вычислена по любой паре точек \((x, y)\) на изображении. Главная идея преобразования Хафа — учесть характеристики прямой не как уравнение, построенное по паре точек изображения, а в терминах её параметров, то есть \(m\) — коэффициента наклона и \(b\) — точки пересечения с осью ординат. Исходя из этого прямая, заданная уравнением \(y = mx + b\), может быть представлена в виде точки с координатами \((b, m)\) в пространстве параметров.

Однако прямые, параллельные оси ординат, имеют бесконечные значения для параметра \(m\). Поэтому удобней представить прямую с помощью других параметров, известных как \(r\) и \(\theta\). Параметр \(r\)  — это длина радиус-вектора ближайшей к началу координат точки на прямой (т.е. нормали к прямой, проведенной из начала координат), а \(\theta\) — это угол между этим вектором и осью абсцисс. При таком описании прямых не возникают бесконечные параметры.

Таким образом, уравнение прямой можно записать как:
\begin{gather}
y = \frac{-\cos{\theta}}{\sin{\theta}}x + \frac{r}{\sin {\theta}}
\end{gather}
или
\begin{gather}
r = x\cos{\theta} + y\sin{\theta}
\end{gather}

\section{Анализ алгоритмов удаление невидимых линий}
\subsection{Алгоритм Робертса}
Алгоритм Робертса представляет собой первое известное решение задачи об удалении невидимых линий. Это метод, работающий в объектном пространстве. В соответствии с алгоритмом, прежде всего удаляются из каждого тела те ребра или грани, которые перекрываются самим телом. Затем каждое из видимых ребер каждого тела сравнивается с каждым из оставшихся тел для определения того, какая его часть или части, если таковые есть, перекрываются этими телами.
 
Преимущества данного алгоритма в том, что математические методы, используемые в нем, просты, мощны и точны. Более поздние реализации алгоритма, например использующие предварительную сортировку вдоль оси z, демонстрируют почти линейную зависимость от числа объектов.

Минус этого алгоритма в том, что вычислительная трудоемкость алгоритма Робертса растет теоретически, как квадрат числа объектов. Реализация оптимизированных алгоритмов весьма сложна.

\subsection{Трассировка лучей}
В этом методе для каждого пикселя картинной плоскости определяется ближайшая к нему грань, для чего через этот пиксель выпускается луч, находятся все его пересечения с гранями и среди них выбирается ближайшая. 

К достоинствам данного алгоритма можно отнести возможность получения изображения гладких объектов без аппроксимации их примитивами (например, треугольниками). Вычислительная сложность метода линейно зависит от сложности сцены. Нетрудно реализовать наложение света и тени на объекты. Качество полученного изображения получается очень реалистичным, этот метод отлично подходит для создания фотореалистичных картин.

Серьёзным недостатком алгоритма трассирования является производительность. Для получения изображения необходимо создавать огромное число лучей, проходящих через сцену и отражаемых от объекта. Это приводит к существенному снижению скорости работы программы.

\subsection{Алгоритм, использующий z-буффер}
Алгоритм, использующий z-буфер это один из простейших алгоритмов удаления невидимых поверхностей. Впервые он был предложен Кэтмулом. Работает этот алгоритм в пространстве изображения. Идея z-буфера является простым обобщением идеи о буфере кадра. Буфер кадра используется для запоминания атрибутов (интенсивности) каждого пиксела в пространстве изображения, z-буфер - это отдельный буфер глубины, используемый для запоминания координаты z или глубины каждого видимого пиксела в пространстве изображения. В процессе работы глубина или значение z каждого нового пиксела, который нужно занести в буфер кадра, сравнивается с глубиной того пиксела, который уже занесен в z-буфер. Если это сравнение показывает, что новый пиксел расположен впереди пиксела, находящегося в буфере кадра, то новый пиксел заносится в этот буфер и, кроме того, производится корректировка z-буфера новым значением z. Если же сравнение дает противоположный результат, то никаких действий не производится. По сути, алгоритм является поиском по х и у наибольшего значения функции \(z(x,y)\).

Главное преимущество алгоритма – его простота. Кроме того, этот алгоритм решает задачу об удалении невидимых поверхностей и делает тривиальной визуализацию пересечений сложных поверхностей. Сцены могут быть любой сложности. Поскольку габариты пространства изображения фиксированы, оценка вычислительной трудоемкости алгоритма не более чем линейна. Поскольку элементы сцены или картинки можно заносить в буфер кадра или в z-буфер в произвольном порядке, их не нужно предварительно сортировать по приоритету глубины. Поэтому экономится вычислительное время, затрачиваемое на сортировку по глубине.

Основной недостаток алгоритма - большой объем требуемой памяти. Если сцена подвергается видовому преобразованию и отсекается до фиксированного диапазона значений координат z, то можно использовать z-буфер с фиксированной точностью. Информацию о глубине нужно обрабатывать с большей точностью, чем координатную информацию на плоскости \((x, y)\); обычно бывает достаточно 20-ти бит. Буфер кадра размером 512x512x24 бит в комбинации с z-буфером размером 512x512x20 бит требует почти 1.5 мегабайт памяти. Однако снижение цен на память делает экономически оправданным создание специализированных запоминающих устройств для z-буфера и связанной с ним аппаратуры.

\section{Анализ модели освещения по Фонгу}
Расчет освещения по Фонгу требует вычисления цветовой интенсивности трех компонент освещения: фоновой, рассеянной  и глянцевых бликов . Фоновая компонента — грубое приближение лучей света, рассеянных соседними объектами и затем достигших заданной точки; остальные две компоненты имитируют рассеивание и отражение прямого излучения.

Иллюстрация различных компонент, соединенных в модели Фонга
\begin{gather}
{\displaystyle I=K_{a}I_{a}+K_{d}({\vec {n}},{\vec {l}})+K_{s}({\vec {n}},{\vec {h}})^{p}}
\end{gather}

где

\({\displaystyle {\vec {n}}} \) — вектор нормали к поверхности в точке

\({\displaystyle {\vec {l}}} \)— направление проецирования (направление на источник света)

\({\displaystyle {\vec {h}}} \) — направление на наблюдателя

\({\displaystyle K_{a}}\) — коэффициент фонового освещения

\({\displaystyle K_{s}} \) — коэффициент зеркального освещения

\({\displaystyle K_{d}}\) — коэффициент диффузного освещения

\section{Выводы и выбор алгоритмов для поставленной задачи}
В качестве алгоритма выделения границ был использован на детектор границ Кэнни. Этот алгоритм дает наиболее точную границу, по сравнению со всеми выше описанными. Трансформация Хафа была использована для нахождения проекций цилиндрической поверхности.

Для удаления невидимых граней в трехмерной анимации был выбран алгоритм z-буффера. В силу простоты сцены, нет необходимости использовать эффективные алгоритмы, но в тоже время для сохранения плавности анимации нельзя использовать ресурсоемкие алгоритмы.
