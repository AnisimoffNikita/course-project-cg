format 215
"ObjLoader" // src::3rdparty::ObjLoader
  revision 1
  modified_by 2 "nikita"
  // class settings
  
  classdiagramsettings member_max_width 0 end
  
  usecasediagramsettings end
  
  sequencediagramsettings end
  
  collaborationdiagramsettings end
  
  objectdiagramsettings end
  
  componentdiagramsettings
   end
  
  deploymentdiagramsettings
   end
  
  statediagramsettings
   end
  
  activitydiagramsettings
   end
  
  cpp_h_dir "/home/nikita/Projects/labs/course_project_cg/src/3rdparty/ObjLoader/"
  cpp_src_dir "/home/nikita/Projects/labs/course_project_cg/src/3rdparty/ObjLoader/"
  cpp_namespace "objl"
  classview 128258 "ObjLoader"
    
    classdiagramsettings member_max_width 0 end
    
    collaborationdiagramsettings end
    
    objectdiagramsettings end
    
    sequencediagramsettings end
    
    statediagramsettings
     end
    
    
    activitydiagramsettings
     end
    class 129922 "Vector2"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment " NIKITA CODE
 Structure: Vector2

 Description: A 2D Vector that Holds Positional Data"
      operation 131458 "Vector2"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw}${abstract} {
        X = 0.0f;
        Y = 0.0f;
    };
"
	
	
	
	
	comment " Default Constructor"
      end

      operation 131586 "Vector2"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param in name "X_" explicit_type "float"
	  param in name "Y_" explicit_type "float"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}${)}${volatile}${throw}${abstract} {
        X = X_;
        Y = Y_;
    };
"
	
	
	
	
	comment " Variable Set Constructor"
      end

      operation 131714 "operator =="
	const cpp_inline public explicit_return_type "bool"
	nparams 1
	  param in name "other" type class_ref 129922 // Vector2
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return (this->X == other.X && this->Y == other.Y);
    };
"
	
	
	
	
	comment " Bool Equals Operator Overload"
      end

      operation 131842 "operator !="
	const cpp_inline public explicit_return_type "bool"
	nparams 1
	  param in name "other" type class_ref 129922 // Vector2
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return !(this->X == other.X && this->Y == other.Y);
    };
"
	
	
	
	
	comment " Bool Not Equals Operator Overload"
      end

      operation 131970 "operator +"
	const cpp_inline public return_type class_ref 129922 // Vector2
	nparams 1
	  param in name "right" type class_ref 129922 // Vector2
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return Vector2(this->X + right.X, this->Y + right.Y);
    };
"
	
	
	
	
	comment " Addition Operator Overload"
      end

      operation 132098 "operator -"
	const cpp_inline public return_type class_ref 129922 // Vector2
	nparams 1
	  param in name "right" type class_ref 129922 // Vector2
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return Vector2(this->X - right.X, this->Y - right.Y);
    };
"
	
	
	
	
	comment " Subtraction Operator Overload"
      end

      operation 132226 "operator *"
	const cpp_inline public return_type class_ref 129922 // Vector2
	nparams 1
	  param in name "other" explicit_type "float"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return Vector2(this->X * other, this->Y * other);
    };
"
	
	
	
	
	comment " Float Multiplication Operator Overload"
      end

      attribute 128514 "X"
	public explicit_type "float"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Positional Variables
"
      end

      attribute 128642 "Y"
	public explicit_type "float"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end
    end

    class 130050 "Vector3"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment " Structure: Vector3

 Description: A 3D Vector that Holds Positional Data"
      operation 132354 "Vector3"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw}${abstract} {
        X = 0.0f;
        Y = 0.0f;
        Z = 0.0f;
    };
"
	
	
	
	
	comment " Default Constructor"
      end

      operation 132482 "Vector3"
	cpp_inline public explicit_return_type ""
	nparams 3
	  param in name "X_" explicit_type "float"
	  param in name "Y_" explicit_type "float"
	  param in name "Z_" explicit_type "float"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} ${p0}${v0}, ${t1} ${p1}${v1}, ${t2} ${p2}${v2}${)}${volatile}${throw}${abstract} {
        X = X_;
        Y = Y_;
        Z = Z_;
    };
"
	
	
	
	
	comment " Variable Set Constructor"
      end

      operation 132610 "operator =="
	const cpp_inline public explicit_return_type "bool"
	nparams 1
	  param in name "other" type class_ref 130050 // Vector3
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return (this->X == other.X && this->Y == other.Y && this->Z == other.Z);
    };
"
	
	
	
	
	comment " Bool Equals Operator Overload"
      end

      operation 132738 "operator !="
	const cpp_inline public explicit_return_type "bool"
	nparams 1
	  param in name "other" type class_ref 130050 // Vector3
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return !(this->X == other.X && this->Y == other.Y && this->Z == other.Z);
    };
"
	
	
	
	
	comment " Bool Not Equals Operator Overload"
      end

      operation 132866 "operator +"
	const cpp_inline public return_type class_ref 130050 // Vector3
	nparams 1
	  param in name "right" type class_ref 130050 // Vector3
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return Vector3(this->X + right.X, this->Y + right.Y, this->Z + right.Z);
    };
"
	
	
	
	
	comment " Addition Operator Overload"
      end

      operation 132994 "operator -"
	const cpp_inline public return_type class_ref 130050 // Vector3
	nparams 1
	  param in name "right" type class_ref 130050 // Vector3
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return Vector3(this->X - right.X, this->Y - right.Y, this->Z - right.Z);
    };
"
	
	
	
	
	comment " Subtraction Operator Overload"
      end

      operation 133122 "operator *"
	const cpp_inline public return_type class_ref 130050 // Vector3
	nparams 1
	  param in name "other" explicit_type "float"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}const ${t0} & ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        return Vector3(this->X * other, this->Y * other, this->Z - other);
    };
"
	
	
	
	
	comment " Float Multiplication Operator Overload"
      end

      attribute 128770 "X"
	public explicit_type "float"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Positional Variables
"
      end

      attribute 128898 "Y"
	public explicit_type "float"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end

      attribute 129026 "Z"
	public explicit_type "float"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
      end
    end

    class 130178 "Vertex"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment " Structure: Vertex

 Description: Model Vertex object that holds
  a Position, Normal, and Texture Coordinate"
      classrelation 128642 // Position (<directional composition>)
	relation 128642 *-->
	  a role_name "Position" public
	    comment " Position Vector
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 128642 // Position (<directional composition>)
	  b parent class_ref 130050 // Vector3
      end

      classrelation 128770 // Normal (<directional composition>)
	relation 128770 *-->
	  a role_name "Normal" public
	    comment " Normal Vector
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 128770 // Normal (<directional composition>)
	  b parent class_ref 130050 // Vector3
      end

      classrelation 128898 // TextureCoordinate (<directional composition>)
	relation 128898 *-->
	  a role_name "TextureCoordinate" public
	    comment " Texture Coordinate Vector
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 128898 // TextureCoordinate (<directional composition>)
	  b parent class_ref 129922 // Vector2
      end
    end

    class 130306 "Material"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      operation 133250 "Material"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw}${abstract} {
        //name;
        Ns = 0.0f;
        Ni = 0.0f;
        d = 0.0f;
        illum = 0;
    };
"
	
	
	
	
      end

      attribute 129154 "name"
	public explicit_type "std::string"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Material Name
"
      end

      classrelation 129026 // Ka (<directional composition>)
	relation 129026 *-->
	  a role_name "Ka" public
	    comment " Ambient Color
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 129026 // Ka (<directional composition>)
	  b parent class_ref 130050 // Vector3
      end

      classrelation 129154 // Kd (<directional composition>)
	relation 129154 *-->
	  a role_name "Kd" public
	    comment " Diffuse Color
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 129154 // Kd (<directional composition>)
	  b parent class_ref 130050 // Vector3
      end

      classrelation 129282 // Ks (<directional composition>)
	relation 129282 *-->
	  a role_name "Ks" public
	    comment " Specular Color
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 129282 // Ks (<directional composition>)
	  b parent class_ref 130050 // Vector3
      end

      attribute 129282 "Ns"
	public explicit_type "float"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Specular Exponent
"
      end

      attribute 129410 "Ni"
	public explicit_type "float"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Optical Density
"
      end

      attribute 129538 "d"
	public explicit_type "float"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Dissolve
"
      end

      attribute 129666 "illum"
	public explicit_type "int"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Illumination
"
      end

      attribute 129794 "map_Ka"
	public explicit_type "std::string"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Ambient Texture Map
"
      end

      attribute 129922 "map_Kd"
	public explicit_type "std::string"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Diffuse Texture Map
"
      end

      attribute 130050 "map_Ks"
	public explicit_type "std::string"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Specular Texture Map
"
      end

      attribute 130178 "map_Ns"
	public explicit_type "std::string"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Specular Hightlight Map
"
      end

      attribute 130306 "map_d"
	public explicit_type "std::string"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Alpha Texture Map
"
      end

      attribute 130434 "map_bump"
	public explicit_type "std::string"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Bump Map
"
      end
    end

    class 130434 "Mesh"
      visibility package stereotype "struct"
      cpp_decl "${comment}${template}struct ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment " Structure: Mesh

 Description: A Simple Mesh Object that holds
  a name, a vertex list, and an index list"
      operation 133378 "Mesh"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw}${abstract} {
    };
"
	
	
	
	
	comment " Default Constructor"
      end

      operation 133506 "Mesh"
	cpp_inline public explicit_return_type ""
	nparams 2
	  param inout name "_Vertices" explicit_type "std::vector<Vertex>"
	  param inout name "_Indices" explicit_type "std::vector<unsigned int>"
	cpp_decl "    ${comment}${inline}${name}${(}${t0} & ${p0}${v0}, ${t1} & ${p1}${v1}${)}${volatile}${throw}${abstract} {
        Vertices = _Vertices;
        Indices = _Indices;
    };
"
	
	
	
	
	comment " Variable Set Constructor"
      end

      attribute 130562 "MeshName"
	public explicit_type "std::string"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Mesh Name
"
      end

      classrelation 129410 // Vertices (<directional composition>)
	relation 129410 *-->
	  stereotype "std::vector"
	  a role_name "Vertices" public
	    comment " Vertex List
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	    classrelation_ref 129410 // Vertices (<directional composition>)
	  b parent class_ref 130178 // Vertex
      end

      attribute 130690 "Indices"
	public explicit_type "unsigned int"
	stereotype "std::vector"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Index List
"
      end

      classrelation 129538 // MeshMaterial (<directional composition>)
	relation 129538 *-->
	  a role_name "MeshMaterial" public
	    comment " Material
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${type} ${name}${value};
"
	    classrelation_ref 129538 // MeshMaterial (<directional composition>)
	  b parent class_ref 130306 // Material
      end
    end

    class 130562 "Loader"
      visibility package 
      cpp_decl "${comment}${template}class ${name}${inherit} {
${members}};
${inlines}
"
      java_decl ""
      php_decl ""
      python_2_2 python_decl ""
      idl_decl ""
      explicit_switch_type ""
      mysql_decl ""
      
      comment " Class: Loader

 Description: The OBJ Model Loader"
      operation 133634 "Loader"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${name}${(}${)}${volatile}${throw}${abstract} {
    };
"
	
	
	
	
	comment " Default Constructor"
      end

      operation 133762 "~Loader"
	cpp_inline public explicit_return_type ""
	nparams 0
	cpp_decl "    ${comment}${inline}${virtual}${name}${(}${)}${volatile}${throw}${abstract} {
        LoadedMeshes.clear();
    };
"
	
	
	
	
      end

      operation 133890 "LoadFile"
	cpp_inline public explicit_return_type "bool"
	nparams 1
	  param in name "Path" explicit_type "std::string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        std::setlocale(LC_ALL, \"C\");

        // If the file is not an .obj file return false
        if (Path.substr(Path.size() - 4, 4) != \".obj\")
        {
            return false;
        }

        QFile qfile(Path.c_str());
        //std::ifstream file(Path);

        //if (!file.is_open())
        if (!qfile.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            return false;
        }

        LoadedMeshes.clear();
        LoadedVertices.clear();
        LoadedIndices.clear();
        std::vector<Vector3> Positions;
        std::vector<Vector2> TCoords;
        std::vector<Vector3> Normals;
        std::vector<Vertex> Vertices;
        std::vector<unsigned int> Indices;
        std::vector<std::string> MeshMatNames;
        bool listening = false;
        std::string meshname;
        Mesh tempMesh;
#ifdef OBJL_CONSOLE_OUTPUT
        const unsigned int outputEveryNth = 1000;
        unsigned int outputIndicator = outputEveryNth;
#endif
        std::string curline;
        QString qline;
        QTextStream in(&qfile);

        //while (std::getline(file, curline))
        while (!in.atEnd())
        {
            qline = in.readLine();
            curline = qline.toStdString();
#ifdef OBJL_CONSOLE_OUTPUT

            if ((outputIndicator = ((outputIndicator + 1) % outputEveryNth)) == 1)
            {
                if (!meshname.empty())
                {
                    std::cout
                            << \"\\r- \" << meshname
                            << \"\\t| vertices > \" << Positions.size()
                            << \"\\t| texcoords > \" << TCoords.size()
                            << \"\\t| normals > \" << Normals.size()
                            << \"\\t| triangles > \" << (Vertices.size() / 3)
                            << (!MeshMatNames.empty() ? \"\\t| material: \" + MeshMatNames.back() : \"\");
                }
            }

#endif

            // Generate a Mesh Object or Prepare for an object to be created
            if (algorithm::firstToken(curline) == \"o\" ||
                    algorithm::firstToken(curline) == \"g\" || curline[0] == 'g')
            {
                if (!listening)
                {
                    listening = true;

                    if (algorithm::firstToken(curline) == \"o\" ||
                            algorithm::firstToken(curline) == \"g\")
                    {
                        meshname = algorithm::tail(curline);
                    }
                    else
                    {
                        meshname = \"unnamed\";
                    }
                }
                else
                {
                    // Generate the mesh to put into the array
                    if (!Indices.empty() && !Vertices.empty())
                    {
                        // Create Mesh
                        tempMesh = Mesh(Vertices, Indices);
                        tempMesh.MeshName = meshname;
                        // Insert Mesh
                        LoadedMeshes.push_back(tempMesh);
                        // Cleanup
                        Vertices.clear();
                        Indices.clear();
                        meshname.clear();
                        meshname = algorithm::tail(curline);
                    }
                    else
                    {
                        if (algorithm::firstToken(curline) == \"o\" ||
                                algorithm::firstToken(curline) == \"g\")
                        {
                            meshname = algorithm::tail(curline);
                        }
                        else
                        {
                            meshname = \"unnamed\";
                        }
                    }
                }

#ifdef OBJL_CONSOLE_OUTPUT
                std::cout << std::endl;
                outputIndicator = 0;
#endif
            }

            // Generate a Vertex Position
            if (algorithm::firstToken(curline) == \"v\")
            {
                std::vector<std::string> spos;
                Vector3 vpos;
                algorithm::split(algorithm::tail(curline), spos, \" \");
                vpos.X = std::stod(spos[0]);
                vpos.Y = std::stod(spos[1]);
                vpos.Z = std::stod(spos[2]);
                Positions.push_back(vpos);
            }

            // Generate a Vertex Texture Coordinate
            if (algorithm::firstToken(curline) == \"vt\")
            {
                std::vector<std::string> stex;
                Vector2 vtex;
                algorithm::split(algorithm::tail(curline), stex, \" \");
                vtex.X = std::stof(stex[0]);
                vtex.Y = std::stof(stex[1]);
                TCoords.push_back(vtex);
            }

            // Generate a Vertex Normal;
            if (algorithm::firstToken(curline) == \"vn\")
            {
                std::vector<std::string> snor;
                Vector3 vnor;
                algorithm::split(algorithm::tail(curline), snor, \" \");
                vnor.X = std::stod(snor[0]);
                vnor.Y = std::stod(snor[1]);
                vnor.Z = std::stod(snor[2]);
                Normals.push_back(vnor);
            }

            // Generate a Face (vertices & indices)
            if (algorithm::firstToken(curline) == \"f\")
            {
                // Generate the vertices
                std::vector<Vertex> vVerts;
                GenVerticesFromRawOBJ(vVerts, Positions, TCoords, Normals, curline);

                // Add Vertices
                for (int i = 0; i < int(vVerts.size()); i++)
                {
                    Vertices.push_back(vVerts[i]);
                    LoadedVertices.push_back(vVerts[i]);
                }

                std::vector<unsigned int> iIndices;
                VertexTriangluation(iIndices, vVerts);

                // Add Indices
                for (int i = 0; i < int(iIndices.size()); i++)
                {
                    unsigned int indnum = (unsigned int)((Vertices.size()) - vVerts.size()) +
                                          iIndices[i];
                    Indices.push_back(indnum);
                    indnum = (unsigned int)((LoadedVertices.size()) - vVerts.size()) + iIndices[i];
                    LoadedIndices.push_back(indnum);
                }
            }

            // Get Mesh Material Name
            if (algorithm::firstToken(curline) == \"usemtl\")
            {
                MeshMatNames.push_back(algorithm::tail(curline));

                // Create new Mesh, if Material changes within a group
                if (!Indices.empty() && !Vertices.empty())
                {
                    // Create Mesh
                    tempMesh = Mesh(Vertices, Indices);
                    tempMesh.MeshName = meshname;
                    int i = 2;

                    while (1)
                    {
                        tempMesh.MeshName = meshname + \"_\" + std::to_string(i);

                        for (auto &m : LoadedMeshes)
                            if (m.MeshName == tempMesh.MeshName)
                            {
                                continue;
                            }

                        break;
                    }

                    // Insert Mesh
                    LoadedMeshes.push_back(tempMesh);
                    // Cleanup
                    Vertices.clear();
                    Indices.clear();
                }

#ifdef OBJL_CONSOLE_OUTPUT
                outputIndicator = 0;
#endif
            }

            // Load Materials
            if (algorithm::firstToken(curline) == \"mtllib\")
            {
                // Generate LoadedMaterial
                // Generate a path to the material file
                std::vector<std::string> temp;
                algorithm::split(Path, temp, \"/\");
                std::string pathtomat = \"\";

                if (temp.size() != 1)
                {
                    for (int i = 0; i < temp.size() - 1; i++)
                    {
                        pathtomat += temp[i] + \"/\";
                    }
                }

                pathtomat += algorithm::tail(curline);
#ifdef OBJL_CONSOLE_OUTPUT
                std::cout << std::endl << \"- find materials in: \" << pathtomat << std::endl;
#endif
                // Load Materials
                LoadMaterials(pathtomat);
            }
        }

#ifdef OBJL_CONSOLE_OUTPUT
        std::cout << std::endl;
#endif

        // Deal with last mesh

        if (!Indices.empty() && !Vertices.empty())
        {
            // Create Mesh
            tempMesh = Mesh(Vertices, Indices);
            tempMesh.MeshName = meshname;
            // Insert Mesh
            LoadedMeshes.push_back(tempMesh);
        }

        //file.close();
        qfile.close();

        // Set Materials for each Mesh
        for (int i = 0; i < MeshMatNames.size(); i++)
        {
            std::string matname = MeshMatNames[i];

            // Find corresponding material name in loaded materials
            // when found copy material variables into mesh material
            for (int j = 0; j < LoadedMaterials.size(); j++)
            {
                if (LoadedMaterials[j].name == matname)
                {
                    LoadedMeshes[i].MeshMaterial = LoadedMaterials[j];
                    break;
                }
            }
        }

        if (LoadedMeshes.empty() && LoadedVertices.empty() && LoadedIndices.empty())
        {
            return false;
        }
        else
        {
            return true;
        }
    };
"
	
	
	
	
	comment " Load a file into the loader

 If file is loaded return true

 If the file is unable to be found
 or unable to be loaded return false"
      end

      classrelation 129666 // LoadedMeshes (<directional composition>)
	relation 129666 *-->
	  stereotype "std::vector"
	  a role_name "LoadedMeshes" public
	    comment " Loaded Mesh Objects
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	    classrelation_ref 129666 // LoadedMeshes (<directional composition>)
	  b parent class_ref 130434 // Mesh
      end

      classrelation 129794 // LoadedVertices (<directional composition>)
	relation 129794 *-->
	  stereotype "std::vector"
	  a role_name "LoadedVertices" public
	    comment " Loaded Vertex Objects
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	    classrelation_ref 129794 // LoadedVertices (<directional composition>)
	  b parent class_ref 130178 // Vertex
      end

      attribute 130818 "LoadedIndices"
	public explicit_type "unsigned int"
	stereotype "std::vector"
	cpp_decl "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	java_decl ""
	php_decl ""
	python_decl ""
	idl_decl ""
	mysql_decl ""
	MysqlColumn
	comment " Loaded Index Positions
"
      end

      classrelation 129922 // LoadedMaterials (<directional composition>)
	relation 129922 *-->
	  stereotype "std::vector"
	  a role_name "LoadedMaterials" public
	    comment " Loaded Material Objects
"
	    cpp default "    ${comment}${static}${thread_local}${mutable}${volatile}${const}${stereotype}<${type}> ${name}${value};
"
	    classrelation_ref 129922 // LoadedMaterials (<directional composition>)
	  b parent class_ref 130306 // Material
      end

      operation 134018 "GenVerticesFromRawOBJ"
	cpp_inline private explicit_return_type "void"
	nparams 5
	  param inout name "oVerts" explicit_type "std::vector<Vertex>"
	  param in name "iPositions" explicit_type "std::vector<Vector3>"
	  param in name "iTCoords" explicit_type "std::vector<Vector2>"
	  param in name "iNormals" explicit_type "std::vector<Vector3>"
	  param in name "icurline" explicit_type "std::string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}, const ${t2} & ${p2}${v2}, const ${t3} & ${p3}${v3}, ${t4} ${p4}${v4}${)}${const}${volatile}${throw}${abstract} {
        std::vector<std::string> sface, svert;
        Vertex vVert;
        algorithm::split(algorithm::tail(icurline), sface, \" \");
        bool noNormal = false;

        // For every given vertex do this
        for (int i = 0; i < int(sface.size()); i++)
        {
            // See What type the vertex is.
            int vtype;
            algorithm::split(sface[i], svert, \"/\");

            // Check for just position - v1
            if (svert.size() == 1)
            {
                // Only position
                vtype = 1;
            }

            // Check for position & texture - v1/vt1
            if (svert.size() == 2)
            {
                // Position & Texture
                vtype = 2;
            }

            // Check for Position, Texture and Normal - v1/vt1/vn1
            // or if Position and Normal - v1//vn1
            if (svert.size() == 3)
            {
                if (svert[1] != \"\")
                {
                    // Position, Texture, and Normal
                    vtype = 4;
                }
                else
                {
                    // Position & Normal
                    vtype = 3;
                }
            }

            // Calculate and store the vertex
            switch (vtype)
            {
            case 1: // P
            {
                vVert.Position = algorithm::getElement(iPositions, svert[0]);
                vVert.TextureCoordinate = Vector2(0, 0);
                noNormal = true;
                oVerts.push_back(vVert);
                break;
            }

            case 2: // P/T
            {
                vVert.Position = algorithm::getElement(iPositions, svert[0]);
                vVert.TextureCoordinate = algorithm::getElement(iTCoords, svert[1]);
                noNormal = true;
                oVerts.push_back(vVert);
                break;
            }

            case 3: // P//N
            {
                vVert.Position = algorithm::getElement(iPositions, svert[0]);
                vVert.TextureCoordinate = Vector2(0, 0);
                vVert.Normal = algorithm::getElement(iNormals, svert[2]);
                oVerts.push_back(vVert);
                break;
            }

            case 4: // P/T/N
            {
                vVert.Position = algorithm::getElement(iPositions, svert[0]);
                vVert.TextureCoordinate = algorithm::getElement(iTCoords, svert[1]);
                vVert.Normal = algorithm::getElement(iNormals, svert[2]);
                oVerts.push_back(vVert);
                break;
            }

            default:
            {
                break;
            }
            }
        }

        // take care of missing normals
        // these may not be truly acurate but it is the
        // best they get for not compiling a mesh with normals
        if (noNormal)
        {
            Vector3 A = oVerts[0].Position - oVerts[1].Position;
            Vector3 B = oVerts[2].Position - oVerts[1].Position;
            Vector3 normal = math::CrossV3(A, B);

            for (int i = 0; i < int(oVerts.size()); i++)
            {
                oVerts[i].Normal = normal;
            }
        }
    };
"
	
	
	
	
	comment " Generate vertices from a list of positions,
  tcoords, normals and a face line"
      end

      operation 134146 "VertexTriangluation"
	cpp_inline private explicit_return_type "void"
	nparams 2
	  param inout name "oIndices" explicit_type "std::vector<unsigned int>"
	  param in name "iVerts" explicit_type "std::vector<Vertex>"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} & ${p0}${v0}, const ${t1} & ${p1}${v1}${)}${const}${volatile}${throw}${abstract} {
        // If there are 2 or less verts,
        // no triangle can be created,
        // so exit
        if (iVerts.size() < 3)
        {
            return;
        }

        // If it is a triangle no need to calculate it
        if (iVerts.size() == 3)
        {
            oIndices.push_back(0);
            oIndices.push_back(1);
            oIndices.push_back(2);
            return;
        }

        // Create a list of vertices
        std::vector<Vertex> tVerts = iVerts;

        while (true)
        {
            // For every vertex
            for (int i = 0; i < int(tVerts.size()); i++)
            {
                // pPrev = the previous vertex in the list
                Vertex pPrev;

                if (i == 0)
                {
                    pPrev = tVerts[tVerts.size() - 1];
                }
                else
                {
                    pPrev = tVerts[i - 1];
                }

                // pCur = the current vertex;
                Vertex pCur = tVerts[i];
                // pNext = the next vertex in the list
                Vertex pNext;

                if (i == tVerts.size() - 1)
                {
                    pNext = tVerts[0];
                }
                else
                {
                    pNext = tVerts[i + 1];
                }

                // Check to see if there are only 3 verts left
                // if so this is the last triangle
                if (tVerts.size() == 3)
                {
                    // Create a triangle from pCur, pPrev, pNext
                    for (int j = 0; j < int(tVerts.size()); j++)
                    {
                        if (iVerts[j].Position == pCur.Position)
                        {
                            oIndices.push_back(j);
                        }

                        if (iVerts[j].Position == pPrev.Position)
                        {
                            oIndices.push_back(j);
                        }

                        if (iVerts[j].Position == pNext.Position)
                        {
                            oIndices.push_back(j);
                        }
                    }

                    tVerts.clear();
                    break;
                }

                if (tVerts.size() == 4)
                {
                    // Create a triangle from pCur, pPrev, pNext
                    for (int j = 0; j < int(iVerts.size()); j++)
                    {
                        if (iVerts[j].Position == pCur.Position)
                        {
                            oIndices.push_back(j);
                        }

                        if (iVerts[j].Position == pPrev.Position)
                        {
                            oIndices.push_back(j);
                        }

                        if (iVerts[j].Position == pNext.Position)
                        {
                            oIndices.push_back(j);
                        }
                    }

                    Vector3 tempVec;

                    for (int j = 0; j < int(tVerts.size()); j++)
                    {
                        if (tVerts[j].Position != pCur.Position
                                && tVerts[j].Position != pPrev.Position
                                && tVerts[j].Position != pNext.Position)
                        {
                            tempVec = tVerts[j].Position;
                            break;
                        }
                    }

                    // Create a triangle from pCur, pPrev, pNext
                    for (int j = 0; j < int(iVerts.size()); j++)
                    {
                        if (iVerts[j].Position == pPrev.Position)
                        {
                            oIndices.push_back(j);
                        }

                        if (iVerts[j].Position == pNext.Position)
                        {
                            oIndices.push_back(j);
                        }

                        if (iVerts[j].Position == tempVec)
                        {
                            oIndices.push_back(j);
                        }
                    }

                    tVerts.clear();
                    break;
                }

                // If Vertex is not an interior vertex
                float angle = math::AngleBetweenV3(pPrev.Position - pCur.Position,
                                                   pNext.Position - pCur.Position) * (180 / 3.14159265359);

                if (angle <= 0 && angle >= 180)
                {
                    continue;
                }

                // If any vertices are within this triangle
                bool inTri = false;

                for (int j = 0; j < int(iVerts.size()); j++)
                {
                    if (algorithm::inTriangle(iVerts[j].Position, pPrev.Position, pCur.Position,
                                              pNext.Position)
                            && iVerts[j].Position != pPrev.Position
                            && iVerts[j].Position != pCur.Position
                            && iVerts[j].Position != pNext.Position)
                    {
                        inTri = true;
                        break;
                    }
                }

                if (inTri)
                {
                    continue;
                }

                // Create a triangle from pCur, pPrev, pNext
                for (int j = 0; j < int(iVerts.size()); j++)
                {
                    if (iVerts[j].Position == pCur.Position)
                    {
                        oIndices.push_back(j);
                    }

                    if (iVerts[j].Position == pPrev.Position)
                    {
                        oIndices.push_back(j);
                    }

                    if (iVerts[j].Position == pNext.Position)
                    {
                        oIndices.push_back(j);
                    }
                }

                // Delete pCur from the list
                for (int j = 0; j < int(tVerts.size()); j++)
                {
                    if (tVerts[j].Position == pCur.Position)
                    {
                        tVerts.erase(tVerts.begin() + j);
                        break;
                    }
                }

                // reset i to the start
                // -1 since loop will add 1 to it
                i = -1;
            }

            // if no triangles were created
            if (oIndices.size() == 0)
            {
                break;
            }

            // if no more vertices
            if (tVerts.size() == 0)
            {
                break;
            }
        }
    };
"
	
	
	
	
	comment " Triangulate a list of vertices into a face by printing
  inducies corresponding with triangles within it"
      end

      operation 134274 "LoadMaterials"
	cpp_inline private explicit_return_type "bool"
	nparams 1
	  param in name "path" explicit_type "std::string"
	cpp_decl "    ${comment}${friend}${static}${inline}${virtual}${type} ${name}${(}${t0} ${p0}${v0}${)}${const}${volatile}${throw}${abstract} {
        // If the file is not a material file return false
        if (path.substr(path.size() - 4, path.size()) != \".mtl\")
        {
            return false;
        }

        //std::ifstream file(path);
        QFile qfile(path.c_str());

        // If the file is not found return false
        //if (!file.is_open())
        if (!qfile.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            return false;
        }

        Material tempMaterial;
        bool listening = false;
        // Go through each line looking for material variables
        std::string curline;
        QString qline;
        QTextStream in(&qfile);

        //while (std::getline(file, curline))
        while (!in.atEnd())
        {
            qline = in.readLine();
            curline = qline.toStdString();

            // new material and material name
            if (algorithm::firstToken(curline) == \"newmtl\")
            {
                if (!listening)
                {
                    listening = true;

                    if (curline.size() > 7)
                    {
                        tempMaterial.name = algorithm::tail(curline);
                    }
                    else
                    {
                        tempMaterial.name = \"none\";
                    }
                }
                else
                {
                    // Generate the material
                    // Push Back loaded Material
                    LoadedMaterials.push_back(tempMaterial);
                    // Clear Loaded Material
                    tempMaterial = Material();

                    if (curline.size() > 7)
                    {
                        tempMaterial.name = algorithm::tail(curline);
                    }
                    else
                    {
                        tempMaterial.name = \"none\";
                    }
                }
            }

            // Ambient Color
            if (algorithm::firstToken(curline) == \"Ka\")
            {
                std::vector<std::string> temp;
                algorithm::split(algorithm::tail(curline), temp, \" \");

                if (temp.size() != 3)
                {
                    continue;
                }

                tempMaterial.Ka.X = std::stof(temp[0]);
                tempMaterial.Ka.Y = std::stof(temp[1]);
                tempMaterial.Ka.Z = std::stof(temp[2]);
            }

            // Diffuse Color
            if (algorithm::firstToken(curline) == \"Kd\")
            {
                std::vector<std::string> temp;
                algorithm::split(algorithm::tail(curline), temp, \" \");

                if (temp.size() != 3)
                {
                    continue;
                }

                tempMaterial.Kd.X = std::stof(temp[0]);
                tempMaterial.Kd.Y = std::stof(temp[1]);
                tempMaterial.Kd.Z = std::stof(temp[2]);
            }

            // Specular Color
            if (algorithm::firstToken(curline) == \"Ks\")
            {
                std::vector<std::string> temp;
                algorithm::split(algorithm::tail(curline), temp, \" \");

                if (temp.size() != 3)
                {
                    continue;
                }

                tempMaterial.Ks.X = std::stof(temp[0]);
                tempMaterial.Ks.Y = std::stof(temp[1]);
                tempMaterial.Ks.Z = std::stof(temp[2]);
            }

            // Specular Exponent
            if (algorithm::firstToken(curline) == \"Ns\")
            {
                tempMaterial.Ns = std::stof(algorithm::tail(curline));
            }

            // Optical Density
            if (algorithm::firstToken(curline) == \"Ni\")
            {
                tempMaterial.Ni = std::stof(algorithm::tail(curline));
            }

            // Dissolve
            if (algorithm::firstToken(curline) == \"d\")
            {
                tempMaterial.d = std::stof(algorithm::tail(curline));
            }

            // Illumination
            if (algorithm::firstToken(curline) == \"illum\")
            {
                tempMaterial.illum = std::stoi(algorithm::tail(curline));
            }

            // Ambient Texture Map
            if (algorithm::firstToken(curline) == \"map_Ka\")
            {
                tempMaterial.map_Ka = algorithm::tail(curline);
            }

            // Diffuse Texture Map
            if (algorithm::firstToken(curline) == \"map_Kd\")
            {
                tempMaterial.map_Kd = algorithm::tail(curline);
            }

            // Specular Texture Map
            if (algorithm::firstToken(curline) == \"map_Ks\")
            {
                tempMaterial.map_Ks = algorithm::tail(curline);
            }

            // Specular Hightlight Map
            if (algorithm::firstToken(curline) == \"map_Ns\")
            {
                tempMaterial.map_Ns = algorithm::tail(curline);
            }

            // Alpha Texture Map
            if (algorithm::firstToken(curline) == \"map_d\")
            {
                tempMaterial.map_d = algorithm::tail(curline);
            }

            // Bump Map
            if (algorithm::firstToken(curline) == \"map_Bump\" ||
                    algorithm::firstToken(curline) == \"map_bump\")
            {
                tempMaterial.map_bump = algorithm::tail(curline);
            }
        }

        // Deal with last material
        // Push Back loaded Material
        LoadedMaterials.push_back(tempMaterial);
        qfile.close();

        // Test to see if anything was loaded
        // If not return false
        if (LoadedMaterials.empty())
        {
            return false;
        }
        // If so return true
        else
        {
            return true;
        }
    };
"
	
	
	
	
	comment " Load Materials from .mtl file"
      end
    end
  end

  deploymentview 128130 "ObjLoader"
    //deployment diagram settings
    deploymentdiagramsettings
     end
    artifact 128386 "objloader"
      stereotype "source"
      cpp_h "#ifndef ${NAMESPACE}_${NAME}_H
#define ${NAMESPACE}_${NAME}_H

${comment}
${includes}
${declarations}
${namespace_start}
${definition}
${namespace_end}
#endif
"
      cpp_src "${comment}
${includes}
${namespace_start}
${members}
${namespace_end}"
      associated_elems
	class_ref 129922 // Vector2
	class_ref 130050 // Vector3
	class_ref 130178 // Vertex
	class_ref 130306 // Material
	class_ref 130434 // Mesh
	class_ref 130562 // Loader
      end
    end
  end
end
